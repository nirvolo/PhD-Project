"0","#################################### The following code is used for the calculating the intercept in the case of simulation ###################################"
"0","# County means are per centroid"
"0","cmn = array(dim=c(dim(best_fit$cnty_means[[2]]),2))"
"0","cmn[,,1] <- as.matrix(best_fit$cnty_means[[1]])"
"0","cmn[,,2] <- as.matrix(best_fit$cnty_means[[2]])"
"0","mnfd_ = fd(cmn, best_fit$fpca_eigen$harmonics$basis)"
"0","min=1  # min 1 max 2"
"0","max = 2"
"0","# # loc_indx = 1"
"0","# # Harmonics scores of location means"
"0","# # FIRST METHOD using inprod.bspline"
"0","# mn_scrs_min = matrix(NA,dim(scl_locs)[1],dim(best_fit$fpca_eigen$harmonics$coefs)[1])"
"0","# mn_scrs_max = matrix(NA,dim(scl_locs)[1],dim(best_fit$fpca_eigen$harmonics$coefs)[1])"
"0","# for (loc_indx in 1:dim(scl_locs)[1]) {"
"0","#   mn_scrs_min[loc_indx,] = inprod.bspline(mnfd_[loc_indx,min], best_fit$fpca_eigen$harmonics[,min,])"
"0","#   mn_scrs_max[loc_indx,] = inprod.bspline(mnfd_[loc_indx,max], best_fit$fpca_eigen$harmonics[,max,])"
"0","# }"
"0","# dim(mn_scrs_min)"
"0","# # mn_scrs_max"
"0","# harms = 5"
"0","# "
"0","# "
"0","# # Logic to calculate a0 from a0*, basically remove the part of the location means of beta*x from the first"
"0","# # coefficient estimate"
"0","# # For each gris point find its smallest distance to centroids and take the county mean for that location"
"0","# #min(crossdist(grd_pt, scl_locs))"
"0","# mean_scores_min_per_loc = matrix(NA, dim(grid_pts)[1], harms)"
"0","# mean_scores_max_per_loc = matrix(NA, dim(grid_pts)[1], harms)"
"0","# for (i in 1:dim(grid_pts)[1]) {"
"0","#   # index of minimum distance"
"0","#   nearset_loc_indx = which.min(crossdist(grid_pts[i,1], grid_pts[i,2], scl_locs[,1], scl_locs[,2]))"
"0","#   mean_scores_min_per_loc[i,] = mn_scrs_min[nearset_loc_indx, 1:harms]"
"0","#   mean_scores_max_per_loc[i,] = mn_scrs_max[nearset_loc_indx, 1:harms]"
"0","# }"
"0","# alpha_star = est_coefs[,1]"
"0","# alpha = c()"
"0","# for (i in 1:length(alpha_star)){"
"0","#   betas_times_mean = sum(est_coefs[3:7]*(mean_scores_min_per_loc[i,] + mean_scores_max_per_loc[i,]))"
"0","#   alpha[i] = alpha_star[i] - betas_times_mean"
"0","# }"
"0","# "
"0",""
"0",""
"0",""
"0",""
"0","# SECOND METHOD using proj.mfpca_nv"
"0","mn_scrs_ = matrix(NA,dim(scl_locs)[1],dim(best_fit$fpca_eigen$harmonics$coefs)[1], 2)"
"0","for (loc_indx in 1:dim(scl_locs)[1]) {"
"0","  mn_scrs_ = proj.mfpca_nv(best_fit$fpca_eigen, mnfd_, cntr = F)"
"0","}"
"0",""
"0","harms = 5"
"0","mean_scores_min_per_loc = matrix(NA, dim(grid_pts)[1], harms)"
"0","mean_scores_max_per_loc = matrix(NA, dim(grid_pts)[1], harms)"
"0","for (i in 1:dim(grid_pts)[1]) {"
"0","  # index of minimum distance"
"0","  nearset_loc_indx = which.min(crossdist(grid_pts[i,1], grid_pts[i,2], scl_locs[,1], scl_locs[,2]))"
"0","  mean_scores_min_per_loc[i,] = mn_scrs_[nearset_loc_indx, 1:harms, 1]"
"0","  mean_scores_max_per_loc[i,] = mn_scrs_[nearset_loc_indx, 1:harms, 2]"
"0","}"
"2","Error in mn_scrs_[nearset_loc_indx, 1:harms, 1] : 
  incorrect number of dimensions
"
